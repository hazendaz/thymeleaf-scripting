[[user-guide]]
= MyBatis Thymeleaf User's Guide
:author: The MyBatis Team
:revnumber: x.x.x
:revdate: {localdate}
:toc: left
:icons: font
:source-highlighter: coderay
:imagesdir: ./images
:imagesoutdir: ./images
:docinfodir: ./docinfos
:docinfo1:
:sectnums:
:nofooter:
:sectlinks:
:linkcss:
:xrefstyle: full

// Define variable for urls
:mybatis-doc-url: http://www.mybatis.org/mybatis-3
:travis-ci-url: https://travis-ci.org/mybatis/thymeleaf-scripting
:thymeleaf-doc-url: https://www.thymeleaf.org/doc/tutorials/3.0
:github-organization-url: https://github.com/mybatis
:github-url: {github-organization-url}/thymeleaf-scripting
:github-wiki-url: {github-url}/wiki

// Define dependency artifact versions
:mybatis-version: y.y.y

== Overview

=== What is MyBatis Thymeleaf ?

The mybatis-thymeleaf is a plugin that helps applying the 2-way SQL/dynamic SQL feature to the MyBatis 3
using the template mechanism provided by Thymeleaf 3.
If you are not familiar with MyBatis and Thymeleaf, you can see following official documentations.

* {mybatis-doc-url}[MyBatis 3 REFERENCE DOCUMENTATION^]
* {thymeleaf-doc-url}/usingthymeleaf.html[Tutorial: Using Thymeleaf^]
* {thymeleaf-doc-url}/usingthymeleaf.html#textual-template-modes[Tutorial: Using Thymeleaf -13 Textual template modes-^]

=== What is 2-way SQL?

The 2-way SQL can be used by following *two way*.

* It can be executed as-is in SQL execution tool (such as psql, mysql, sqlplus, plugins for IDE, etc...)
* It can be used as a SQL template for creating a bindable and dynamically SQL that can be parsed by MyBatis core module

==== Simple bindable 2-way SQL

The mybatis-thymeleaf support a simple bindable 2-way SQL as follow:


[source,sql]
.SQL Template
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----


==== Dynamically bindable 2-way SQL

The mybatis-thymeleaf support a dynamically bindable 2-way SQL as follow:

[source,sql]
.SQL Template
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/)
  /*[/]*/
  ORDER BY id
----

==== Dynamically bindable SQL

The mybatis-thymeleaf support a dynamically bindable SQL(non 2-way SQL) as follow:

[source,sql]
.SQL Template
----
SELECT * FROM names
  WHERE 1 = 1
  [# th:if="${not #lists.isEmpty(ids)}"]
    AND id IN ([# mb:p="ids" /])
  [/]
  ORDER BY id
----


=== Mainly Features

The mybatis-thymeleaf provide following features using class that implements
the link:{mybatis-doc-url}/dynamic-sql.html#Pluggable_Scripting_Languages_For_Dynamic_SQL[`LanguageDriver` interface^]
for integrating with template engine provide by Thymeleaf.

* Can write 2-way SQL/dynamic SQL
* Can use a 2-way SQL/dynamic SQL via an annotation and mapper xml
* Can read an SQL template from a Thymeleaf template file on classpath
* Can use a custom dialect(attribute tag and expression utility method) on your SQL template
* Can fully customize a template engine configuration
* Can generate the SQL from SQL template without the MyBatis core module (since 1.0.2)

== Requirements

The mybatis-thymeleaf supports using on following Java and artifacts version.

=== Java

* Java 8, Java 11+

[NOTE]
====
About tested versions see the latest link:{travis-ci-url}[Travis CI^] build result.
====

=== MyBatis

* MyBatis 3.4.3+

[NOTE]
====
As basically policy, we do test using following versions.

* latest release version on 3.5.x line
* latest snapshot version on 3.5.x line
* latest release version on 3.4.x line
====

=== Thymeleaf

* Thymeleaf 3.0+

[NOTE]
====
As basically policy, we do test using following versions.

* latest release version on 3.0.x line
====

== Getting Started

In this chapter, we explain basic usage of the mybatis-thymeleaf.

=== Installation

==== Maven

If you are using the Maven as build tool, you can add as follow:

[source,xml,subs="specialchars,attributes"]
.pom.xml (dependencies)
----
<dependencies>
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>{mybatis-version}</version> <!-- Adjust to your application -->
  </dependency>
  <dependency>
    <groupId>org.mybatis.scripting</groupId>
    <artifactId>mybatis-thymeleaf</artifactId>
    <version>{revnumber}</version>
  </dependency>
</dependencies>
----

If you use a snapshot version, you need add the configuration
for using the "Sonatype OSS Snapshots Repository" as follow:

[source,xml,subs="specialchars,attributes"]
.pom.xml (repositories)
----
<repositories>
  <repository>
    <id>sonatype-oss-snapshots</id>
    <name>Sonatype OSS Snapshots Repository</name>
    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
  </repository>
</repositories>
----

==== Gradle

If you are using the Gradle as build tool, you can add as follow:

[source,groovy,subs="specialchars,attributes"]
.build.gradle (dependencies)
----
dependencies {
  compile("org.mybatis:mybatis:{mybatis-version}") // Adjust version to your application
  compile("org.mybatis.scripting:mybatis-thymeleaf:{revnumber}")
}
----

If you use a snapshot version, you need add the configuration for using the "Sonatype OSS Snapshots Repository" as follow:

[source,groovy,subs="specialchars,attributes"]
.build.gradle (repositories)
----
repositories {
  maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
}
----

=== Configuration

Set the `ThymeleafLanguageDriver` as your default scripting language to MyBatis.

[source,java]
.Configuration class (Java based configuration)
----
Configuration configuration = new Configuration();
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class);
----

[source,xml]
.mybatis-config.xml (XML based configuration)
----
<settings>
  <setting name="defaultScriptingLanguage"
           value="org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"/>
</settings>
----

=== Creating Mapper

The MyBatis provides two ways(annotation driven and XML driven) for creating a Mapper.

==== Annotation driven mapper

If you use the annotation driven mapper, you can specify an SQL as follow:

[source,java]
.src/main/java/com/example/NameMapper.java
----
public class NameMapper {
  @Select("SELECT * FROM names WHERE id = /*[# mb:p='id']*/ 1 /*[/]*/")
  Name findById(Integer id);
}
----

[TIP]
====
You can specify a readable SQL on annotation using "Multiline String Literals" provided by some JVM language.
About "Multiline String Literals", please see the <<Multiline String Literals>>.
====


Also, you can specify an SQL on template file(e.g. `NameMapper/findById.sql` on class path) as follow:

[source,java]
----
@Select("NameMapper/findById.sql")
Name findById(Integer id);
----

By default behavior, the mybatis-thymeleaf read a specified template file from just under classpath.

[[_getting-started-template-sql]]
[source,sql]
.src/main/resources/NameMapper/findById.sql
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----

[TIP]
====
Since 1.0.1, we support to read a template file from under classpath automatically using the <<TemplateFilePathProvider, TemplateFilePathProvider>>.
====


==== XML driven mapper

If you use the XML driven mapper, you can specify an SQL on mapper XML file as follow:

[source,java]
.src/main/java/com/example/NameMapper.java
----
public class NameMapper {
  Name findById(Integer id);
}
----

[source,xml]
.src/main/resources/com/example/NameMapper.xml
----
<mapper namespace="com.example..NameMapper">
  <select id="findById" resultType="com.example.Name">
    <![CDATA[
    SELECT * FROM names
      WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
    ]]>
  </select>
</mapper>
----

Also, you can specify an SQL on template file
(see '<<_getting-started-template-sql,Annotation driven mapper>>' section) as follow:

[source,xml]
----
<select id="findById" resultType="com.example.Name">
  NameMapper/findById.sql
</select>
----

== Configuration

In this chapter, we explain a way for applying mybatis-thymeleaf to the MyBatis in detail.
About MyBatis core module configuration,
please see the {mybatis-doc-url}/configuration.html[MyBatis reference document^].

=== Basic configuration

You configure to use the `org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver` as scripting language driver.

==== Java based configuration

[source,java]
.Configuration class
----
Configuration configuration = new Configuration();
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class); // <1>
// ...
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
----

<1> Set the `ThymeleafLanguageDriver` class to a `Configuration` instance as default scripting language driver

==== XML based configuration

[source,xml]
.src/main/resources/mybatis-config.xml
----
<settings>
  <setting name="defaultScriptingLanguage"
           value="org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"/> // <1>
</settings>
----

[source,java]
----
SqlSessionFactory sqlSessionFactory;
try (Reader configReader = Resources.getResourceAsReader("mybatis-config.xml")) {
  sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader);
}
----

<1> Set the `ThymeleafLanguageDriver` class to the `defaultScriptingLanguage` of setting item in configuration XML file

=== Customizing configuration

The mybatis-thymeleaf provides three ways for customizing template engine configuration.

* <<Using properties file>>
* <<Using functional interface>>
* <<Using user-defined template engine>>

==== Using properties file

The mybatis-thymeleaf provide the special properties file for customizing default configuration.
By default behavior, the mybatis-thymeleaf load the `mybatis-thymeleaf.properties` stored just under classpath.
About supported properties, please see the <<Configuration properties>>.

===== Using an any properties file

You can use an any properties file instead of the default properties file.
If you use an any properties file, please specify a properties file using
the special system properties(`mybatis-thymeleaf.config.file`) as follow:

[source,text]
----
$ java -Dmybatis-thymeleaf.config.file=mybatis-thymeleaf_production.properties ...
----

===== Using an any file encoding

You can use an any file encoding instead of the default file encoding(`UTF-8`).
If you use an any file encoding, please specify a file encoding using
the special system properties(`mybatis-thymeleaf.config.encoding`) as follow:

[source,text]
----
$ java -Dmybatis-thymeleaf.config.encoding=Windows-31J ...
----

==== Using functional interface

The mybatis-thymeleaf provide the special functional
interface(`org.mybatis.scripting.thymeleaf.TemplateEngineCustomizer`) for customizing configurations using Java code.
This feature provide an opportunity to customize configuration that cannot customize it using properties file.

[source,java]
.src/main/java/com/example/MyTemplateEngineCustomizer.java
----
public class MyTemplateEngineCustomizer implements TemplateEngineCustomizer {
  @Override
  public void customize(TemplateEngine defaultTemplateEngine) {
    // ... <1>
  }
}
----

[source,properties]
.src/main/resources/mybatis-thymeleaf.properties
----
customizer = com.example.MyTemplateEngineCustomizer # <2>
----

<1> Write a Java code for customizing template engine

<2> Specify a FQCN of customizer class in `mybatis-thymeleaf.properties`

==== Using user-defined template engine

When your application requirements cannot be satisfied using above customizing features,
you can apply a user-defined template engine(full managed template engine) to the mybatis-thymeleaf as follow:

[source,java]
.Configuration class
----
TemplateEngine templateEngine = new TemplateEngine(); // <1>
templateEngine.addDialect(new MyBatisDialect());
templateEngine.setEngineContextFactory(new MyBatisIntegratingEngineContextFactory(
    templateEngine.getEngineContextFactory()));
// ...

Configuration configuration = new Configuration();
configuration.getLanguageRegistry().register(new ThymeleafLanguageDriver(templateEngine)); // <2>
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class); // <3>
----

<1> Create an instance of class that implements `org.thymeleaf.ITemplateEngine`

<2> Register an instance of `ThymeleafLanguageDriver` that associate with user-defined template engine instance

<3> Set the `ThymeleafLanguageDriver` class as default scripting language driver

== Writing 2-way SQL

In this section, we explain standard usage of 2-way SQL.

[CAUTION]
====
About cautions for usage 2-way SQL, please see the <<Cautions for usage>>.
====


=== Binding value

The mybatis-thymeleaf use the default binding feature provided by MyBatis core module.
Therefore, you need to write a 2-way SQL template for generating string
that can be parsed by MyBatis core module as follow:

[source,sql]
.About default binding feature provided by MyBatis
----
SELECT * FROM names
  WHERE id = #{id} -- <1>
----

[source,sql]
.SQL template for generating string that can be parsed by MyBatis core module
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/ -- <2>
----

<1> A bind value is specified by 「`#{variable name}`」 format
<2> Can render bind variable expression that can be parsed by MyBatis core module using custom attribute tag(`mb:p="variable name"`) provided by mybatis-thymeleaf

[NOTE]
====
**What can you bind?**

Basically, you can bind a parameter object(Mapper method arguments or `SqlSession` method arguments).
In addition, the mybatis-thymeleaf allow to be bind a registered value using `mb:bind` tag.
About usage of `mb:bind`, please see <<Attribute tag>>.
====

=== Dynamic SQL

The Thymeleaf supports to create an any string dynamically using conditional evaluation
and iterating evaluation feature. By using this feature, you can write a dynamic SQL.

* <<Using tag for specifying condition>>
* <<Using tag for iteration>>

==== Using tag for specifying condition

If you add a SQL part when any condition is matches or not, you can use following attribute tags.

* `th:if`
* `th:unless` (denial version for `th:if`)
* `th:switch`
* `th:case`

[source,sql]
.Usage of conditional attribute tag on WHERE
----
SELECT * FROM names
  WHERE 1 = 1 -- <1>
  /*[# th:if="${firstName} != null"]*/ -- <2>
    AND firstName = /*[# mb:p="firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/ -- <3>
  ORDER BY id
----

[source,sql]
.Usage of conditional attribute tag on SET
----
UPDATE names
  SET id = id -- <4>
  /*[# th:if="${firstName} != null"]*/
    , firstName = /*[# mb:p="firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----

<1> Specify a non-dynamic condition at first position because the mybatis-thymeleaf does not provide
    the trimming feature such as `<where>` of XML based scripting language

<2> Specify a condition on start tag using natural template

<3> Specify an end tag of condition

<4> Specify a non-dynamic updating column at first position because the mybatis-thymeleaf does not provide
    the trimming feature such as `<set>` of XML based scripting language

==== Using tag for iteration

The Thymeleaf supports to process for iteration object(`List` etc..) using `th:each`.

[source,sql]
.Basic usage of iteration tag
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (
    /*[# th:each="id : ${ids}"]*/ -- <1>
      /*[# mb:p="id"]*/ 1 /*[/]*/ -- <2>
      /*[(${idStat.last} ? '' : ',')]*/ -- <3>
    /*[/]*/ -- <4>
    )
  /*[/]*/
  ORDER BY id
----

<1> Specify an iterable object on `th:each`

<2> Specify a SQL template of binding value per iterable element.
    A bind value specify by `mb:p="{variable name of iterable element}"` format (e.g. `id`).

<3> Append comma character when element position is not last.
    You can access an iteration status object (`IterationStatusVar`) that named by `"{variable name of iterable element}Stat"` format (e.g. `idStat`).

<4> Specify an end tag of iteration

[TIP]
====
An above SQL template can be replaced using `mb:p` attribute tag with following SQL template.


[source,sql]
.Use mb:p for creating bind variables string of IN clause
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/)
  /*[/]*/
  ORDER BY id
----

Since 1.0.2, We support the indexed access using an iteration status object as follow:

[source,sql]
.Use indexed access using an iteration status object
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (
    /*[# th:each="id : ${ids}"]*/
      /*[# mb:p="ids[${idStat.index}]"]*/ 1 /*[/]*/ -- <1>
      /*[(${idStat.last} ? '' : ',')]*/
    /*[/]*/
    )
  /*[/]*/
  ORDER BY id
----

<1> Access to a iterable object using indexed

====

About more advanced usage of `th:each` , please see <<Bulk insert>>.

=== Fragment

The Thymeleaf supports to insert template string from an another template file.
By using this feature, you can share an SQL on multiple SQL template.

The standard use case using this feature is paging query as follow:

[source,java]
.Mapper interface
----
// Count a total record number that matches for criteria
@Select("NameMapper/countByCriteria.sql")
long countByCriteria(@Param("criteria") NameCriteria criteria);

// Search records that matches for criteria and specified page
@Select("NameMapper/findPageByCriteria.sql")
List<Name> findPageByCriteria(@Param("criteria") NameCriteria criteria, @Param("pageable") Pageable pageable);
----

.src/main/resources/NameMapper/countByCriteria.sql
[source,sql]
----
SELECT COUNT(*) FROM names
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
----

.src/main/resources/NameMapper/findPageByCriteria.sql
[source,sql]
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
  LIMIT /*[# mb:p="pageable.pageSize"]*/ 20 /*[/]*/
  OFFSET /*[# mb:p="pageable.offset"]*/ 0 /*[/]*/
  ORDER BY id
----

Probably looking at above SQLs many developers will look for a way to share the `WHERE` clause.
In such case, you can share any SQL part by multiple SQL using fragment feature.

==== Creating a fragment SQL

At first, you create a fragment SQL template file for sharing by multiple SQL as follow:

.src/main/resources/NameMapper/whereByCriteria.sql
[source,sql]
----
/*[- */ -- <1>
SELECT * FROM names
/* -]*/ -- <2>
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
----

<1> Start a block comment for ignoring `"SELECT * FROM names"` part at template processing time
<2> End a block comment

==== Insert a fragment SQL

You can insert a fragment SQL template file on each template as follow:

.src/main/resources/NameMapper/countByCriteria.sql
[source,sql]
----
SELECT COUNT(*) FROM names
  /*[# th:insert="~{NameMapper/whereByCriteria.sql}" /]*/ -- <1>
----

.src/main/resources/NameMapper/findPageByCriteria.sql
[source,sql]
----
SELECT * FROM names
  /*[# th:insert="~{NameMapper/whereByCriteria.sql}" /]*/ -- <1>
  LIMIT /*[# mb:p="pageable.pageSize"]*/ 20 /*[/]*/
  OFFSET /*[# mb:p="pageable.offset"]*/ 0 /*[/]*/
  ORDER BY id
----

<1> Insert a fragment SQL template file

=== Special variables

The MyBatis core module provides special variables that prefixed with `_` as follows:

[cols="2,7,1",options="header"]
.Special variables
|===
^|Variable Name
^|Description
^|Type

|`_parameter`
|The parameter object that passed to the MyBatis
|Any type

|`_databaseId`
|The id for identifying the database on current session
(If you want to this variable, you should be enabled the link:{mybatis-doc-url}/configuration.html#databaseIdProvider[`DatabaseIdProvider` feature^] on MyBatis)
|`String`
|===

=== Using configuration properties

You can access the configuration properties of MyBatis from your SQL template.
About configuration properties, please see the link:{mybatis-doc-url}/configuration.html#properties[MyBatis reference documentation^].

[source,java]
.How to set configuration properties using Java based configuration
----
Configuration configuration = new Configuration();
Properties variables = new Properties();
variables.setProperty("tableNameOfUser", "accounts"); // <1>
configuration.setVariables(variables);
----

[source,xml]
.How to set configuration properties using XML based configuration (mybatis-config.xml)
----
<properties>
  <property name="tableNameOfUser" value="accounts"/> <!--1-->
</properties>
----

[source,sql]
.SQL template
----
SELECT * FROM /*[# th:utext="${tableNameOfUser} ?: 'users'"]*/ users /*[/]*/ -- <2>
----

<1> Define an any property as MyBatis's configuration properties
<2> Access a configuration property using Thymeleaf's expression

Above SQL template translate to as follows:

[source,sql]
.Translated SQL (when tableNameOfUser is defined)
----
SELECT * FROM accounts
----

[source,sql]
.Translated SQL (when tableNameOfUser is not defined)
----
SELECT * FROM users
----

== Using non 2-way SQL mode

The non 2-way SQL is simple a little compare with 2-way SQL and limitations not found at now.

=== Configuration

By default, the mybatis-thymeleaf will be use the 2-way SQL mode.
Therefore you should be configure explicitly to use the non 2-way SQL mode using configuration properties file or builder option as follow:

[NOTE]
====
This configuration is optional. The non 2-way SQL can be use on the 2-way SQL mode.
====

[source,properties]
.How to configure using configuration properties file(src/main/resources/mybatis-thymeleaf.properties)
----
use2way = false # <1>
----

<1> Set the `use2way` to `false`

[source,java]
.How to configure using config class
----
configuration.getLanguageRegistry().register(new ThymeleafLanguageDriver(
        ThymeleafLanguageDriverConfig.newInstance(c -> c.setUse2Way(false)))); // <1>
----

<1> Set the `use2way` property of `ThymeleafLanguageDriverConfig` to `false`


=== Basic usage

The different with the 2-way SQL mode is that will be unnecessary to enclose the thymeleaf expressions as SQL comment(`/\*[...]*/`).

[source,sql]
.SQL Template
----
SELECT * FROM names
  WHERE 1 = 1
  [# th:if="${not #lists.isEmpty(ids)}"]
    AND id IN (
      [# mb:p="ids" /]
    )
  [/]
  ORDER BY id
----

== Custom Dialect

The mybatis-thymeleaf provide the custom dialect class(`org.mybatis.scripting.thymeleaf.MyBatisDialect`)
that help for generating SQL template.

=== Attribute tag

The mybatis-thymeleaf provides following attribute tags.
By default, you can use it using `mb` dialect prefix (default prefix is initial letter of "**M**y**B**atis").

[cols="2,4,4",options="header"]
.Supported method list
|===
^|Attribute Tag Name
^|Description
^|Attribute Value Format

|<<mybatis-param,p>>
a|Render bind variable(default format: `#{...}`) that can be parsed by MyBatis core module and register an iteration object to the MyBatis's bind variables. +
 +
 The bind variable format decide by a implementation of `BindVariableRender`.
a|`{variableName}(,{optionKey}={optionValue},...)` +
 +
 Valid format is same with link:{mybatis-doc-url}/sqlmap-xml.html#Parameters[MyBatis's inline parameter format^].

|<<mybatis-bind,bind>>
|Register an any value to the MyBatis's bind variables
(Provides a feature similar to that of the link:{mybatis-doc-url}/dynamic-sql.html#bind[`<bind>`^] provided by MyBatis core module)
a|`{variable name}={variable value}(,...)` +
 +
 Valid format is same with `th:with` provided by Thymeleaf.
|===

[[mybatis-param]]
==== p

[source,sql]
.Basic usage:
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/ -- <1>
----

[source,sql]
.Usage with option:
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id,typeHandler=com.example.IdTypeHandler"]*/ 1 /*[/]*/ -- <2>
----

[source,sql]
.Usage for collection and array:
----
SELECT * FROM names
  WHERE id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/) -- <3>
----

<1> Render single bind variable(e.g. `#{id}`) that can be parsed by MyBatis core module when specify a simple value object
<2> Can specify parameter options(`key=value` format) separate with comma
<3> Render multiple bind variables(e.g. `#{ids[0]}, #{ids[1]}, ...`) that can be parsed by MyBatis core module when specify a collection or array object


[[mybatis-bind]]
==== bind

[source,sql]
.Basic usage:
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${firstName} != null"]*/
    /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/ -- <1>
    AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro' /*[/]*/ -- <2>
  /*[/]*/
----

[source,sql]
.Usage for registering multiple variables:
----
/*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|, patternLastName=|${#likes.escapeWildcard(lastName)}%|" /]*/ -- <3>
----

<1> Register an any value(e.g. editing value at template) as custom bind variables
<2> Bind a custom bind variable
<3> Also, you can register multiple custom bind variables separating with comma at the same time

[NOTE]
====
*Why need the bind tag?*

The binding feature provide by MyBatis cannot access a variable that shared by the `th:with`
because it can only access within a template. Hence, the mybatis-thymeleaf provide the `bind` attribute tag.
====

=== Expression utility method

==== #likes expression

The `#likes` expression provide utility methods for LIKE clause.

[cols="1,5a,4",options="header"]
.Supported method list
|===
^|Method
^|Arguments
^|Description

|<<mybatis-escapeLikeWildcard,escapeWildcard>>
|

[cols="^1,4,5",options="header"]
!===
^!No
^!Type
^!Description

!1
!String
!A target value
!===

|Return a value that escaped a wildcard character of LIKE condition.
By default behavior, this method escape the `"%"`, `"_"` and `"\"`(escape character itself) using `"\"`.

|<<mybatis-likeEscapeClause,escapeClause>>
| None
|Return a escape clause string of LIKE condition.
By default behavior, this method return `"ESCAPE '\'"`.
|===


[TIP]
====
You can customize the default behavior for the `escapeWildcard` and `escapeClause`
using <<Configuration properties, Configuration properties>>.
====


[[mybatis-escapeLikeWildcard]]
===== escapeWildcard

[source,sql]
.Basic usage:
----
/*[# th:if="${firstName} != null"]*/
  /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/ -- <1>
  AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro%' /*[/]*/
/*[/]*/
----

<1> Register a value that escaped wildcard character of LIKE condition as custom bind variables

[source,sql]
.Translate to:
----
  AND firstName LIKE #{patternFirstName}
----


[[mybatis-likeEscapeClause]]
===== escapeClause

[source,sql]
.Basic usage:
----
/*[# th:if="${firstName} != null"]*/
  /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/
  AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro%' /*[/]*/ /*[(${#likes.escapeClause()})]*/ -- <1>
/*[/]*/
----

<1> Add `ESCAPE` clause at template processing time

[source,sql]
.Translate to:
----
  AND firstName LIKE #{patternFirstName} ESCAPE '\'
----

== Using SQL Generator

Since 1.0.2, we separate the SQL generating feature from the `ThymeleafLanguageDriver` and `ThymeleafSqlSource` class,
we added the `SqlGenerator` and `SqlGeneratorConfig` for generating SQL from SQL template.
These classes **does not depends on the MyBatis core module**(`mybatis-3.x.x.jar`).
So that, it also can be used in combination with any data access libraries(e.g. Spring JDBC, JPA, R2DBC, etc...) that provide with named parameter.

=== Configuration

By default, the `SqlGenerator` applies settings for using together with the MyBatis core module(apply to `#{...}` as the bind variable format),
but you can customize a default settings using configuration properties file or the `SqlGeneratorConfig`.
The `SqlGeneratorConfig` allows the same configurations as the `ThymeleafLanguageDriverConfig` except the `TemplateFilePathProvider`(`template-file.path-provider.*`).

==== Customize the bind variable format

You can customize the bind variable format using configuration properties file or configuration class.
In the following example, it changes the bind variable format to the Spring JDBC format(e.g. `:id`) from MyBatis core format(e.g. `#{id}`).

[source,properties]
.How to customize using configuration properties file
----
dialect.bind-variable-render = org.mybatis.scripting.thymeleaf.support.spring.SpringNamedParameterBindVariableRender # <1>
----

<1> Specify the `BindVariableRender` implementation class(built-in class) that render Spring JDBC bind variable format


[source,java]
.How to customize using config class
----
SqlGeneratorConfig config = SqlGeneratorConfig.newInstanceWithCustomizer(c ->
    c.getDialect().setBindVariableRender(
        BindVariableRender.BuiltIn.SPRING_NAMED_PARAMETER.getType())); // <1>
SqlGenerator sqlGenerator = new SqlGenerator(config); // <2>
----

<1> Specify the `BindVariableRender` implementation class(built-in class) that render Spring JDBC bind variable format via `BuiltIn` enum
<2> Create a `SqlGenerator` instance with user defined configuration

If you use the custom bind variable format other than built-in format,
please create a implementation class of `BindVariableRender` and apply it to the configuration.

[source,java]
.How to create the BindVariableRender implementation class
----
public class R2dbcMySQLBindVariableRender implements BindVariableRender { // <1>
  public String render(String name) {
    return "?" + name;
  }
}
----

<1> Create a `BindVariableRender` implementation class


==== Customize other configurations

Please see also the following sections.

* <<_customizing_configuration>>


=== Basic Usage

The `SqlGenerator` provide feature for generating a SQL from SQL template using the Thymeleaf as follow:

[source,java]
.Basic Usage:
----
SqlGenerator sqlGenerator = new SqlGenerator(); // <1>

Conditions conditions = new Conditions();
conditions.setId(10);

// sql = "SELECT * FROM accounts WHERE id = #{id}"
String sql = sqlGenerator.generate(
    "SELECT * FROM accounts WHERE id = /*[# mb:p='id']*/ 1 /*[/]*/", conditions); // <2>
----

<1> Create a default instance of `SqlGenerator`
<2> Generate an SQL from SQL template

[NOTE]
====
The `SqlGenerator#generate` method is **thread-safe**. In other words, you can share an `SqlGenerator` instance at any components.
====

==== Specifying custom variables

You can specify any custom variables separately from the parameter object as follow:

[source,java]
.How to use custom variables:
----
SqlGenerator sqlGenerator = new SqlGenerator();
sqlGenerator.setDefaultCustomVariables(
    Collections.singletonMap("accountsTableName", "users")); // <1>

Account account = new Account();
account.setName("Taro Yamada");

Map<String, Object> customVariables = new HashMap<>(); // <2>
customVariables.put("now", LocalDateTime.now());
customVariables.put("loginId", loginId);

// sql = "INSERT INTO users (name, created_at, created_by) VALUES(#{name}, #{now}, #{loginId})"
String sql = sqlGenerator.generate(
    "INSERT INTO /*[# th:utext=\"${accountsTableName} ?: 'accounts'\"]*/ accounts /*[/]*/ " + // <3>
      "(name, created_at, created_by) VALUES(" +
        "/*[# mb:p='name']*/ 'Hanako Yamada' /*[/]*/, " +
        "/*[# mb:p='now']*/ current_timestamp() /*[/]*/, " + // <4>
        "/*[# mb:p='loginId']*/ 'A00000001' /*[/]*/" + // <4>
      ")", account, customVariables); // <5>
----

<1> Specify the default custom variable for sharing by every statements
<2> Create custom variables per statement or transaction
<3> Can be access to a custom variable at template processing time
<4> Can be bind a custom variable
<5> Specify(Pass) custom variables to sql generator at 3rd argument of `generate` method


==== Receiving custom bind variables

You can receiving custom bind variables that created during template processing via a `BiConsumer` function as follow:

[NOTE]
====
The custom bind variables may create when use `mb:bind` or `mb:p` tag.
====

[source,java]
.How to use custom bind variables binder function:
----
SqlGenerator sqlGenerator = new SqlGenerator();

Map<String, Object> conditionsMap = new HashMap<>();
conditionsMap.put("name", "Yamada");

// sql = "SELECT * FROM accounts WHERE name = #{patternName}"
// conditionsMap = {"name":"Yamada", "patternName":"Yamada%"}
String sql = sqlGenerator.generate(
    "/*[# mb:bind='patternName=|${#likes.escapeWildcard(name)}%|' /]*/" +
    "SELECT * FROM accounts WHERE name = /*[# mb:p='patternName']*/ 'Sato' /*[/]*/",
    conditionsMap, null, conditionsMap::put); // <1>
----

<1> Specify(Pass) a `BiConsumer` reference for receiving custom bind variables at 4th argument of `generate` method

=== Advanced Usage

==== Access JavaBeans property

By default, the `SqlGenerator` use the JDK standard APIs(JavaBeans and Reflection API) for accessing a property of user defined Java object.
If there is a conflict with property accessing in the data access library,
you can change a default behavior by applying a custom `org.mybatis.scripting.thymeleaf.PropertyAccessor` implementation class.

[source,java]
.How to apply a custom PropertyAccessor
----
SqlGenerator sqlGenerator = new SqlGenerator();
sqlGenerator.setPropertyAccessor(new MyPropertyAccessor()); // <1>
----

<1> Set a custom `PropertyAccessor` implementation class to the `SqlGenerator`


== Support classes

We provides useful classes for supporting development.

=== TemplateFilePathProvider

The `org.mybatis.scripting.thymeleaf.support.TemplateFilePathProvider` is SQL provider class that return the SQL template file path. This class is available since 1.0.1.
This class use with SQL provider annotation(`@InsertProvider`, `@UpdateProvider`, `@DeleteProvider` and `@SelectProvider`) as follow:

[NOTE]
====
**This class required to use on MyBatis 3.5.1+.**
====

.Usage:

[source, java]
----
package com.example.mapper;

public interface BaseMapper<T> {

  @Options(useGeneratedKeys = true, keyProperty = "id")
  @InsertProvider(type = TemplateFilePathProvider.class)
  void insert(T entity);

  @UpdateProvider(type = TemplateFilePathProvider.class)
  void update(T entity);

  @DeleteProvider(type = TemplateFilePathProvider.class)
  void delete(T entity);

  @SelectProvider(type = TemplateFilePathProvider.class)
  T findById(Integer id);

}
----

[source, java]
----
package com.example.mapper;

public interface NameMapper extends BaseMapper {

  @SelectProvider(type = TemplateFilePathProvider.class)
  List<Name> findByCondition(NameCondition condition);

}
----

By default implementation, a template file path resolve following format and priority order.
If does not match all, it throw an exception that indicate not found a template file.

* `com/example/mapper/NameMapper/NameMapper-{methodName}-{databaseId}.sql`
* `com/example/mapper/NameMapper/NameMapper-{methodName}.sql` +
  (fallback using default database)
* `com/example/mapper/BaseMapper/BaseMapper-{methodName}-{databaseId}.sql` +
  (fallback using declaring class of mapper method)
* `com/example/mapper/BaseMapper/BaseMapper-{methodName}.sql` +
  (fallback using declaring class of mapper method and default database)

If you want to customize the template file path format,
you can customize using the <<Configuration properties, configuration properties>> that start with `template-file.path-provider`.

=== SpringNamedParameterBindVariableRender

The `org.mybatis.scripting.thymeleaf.support.spring.SpringNamedParameterBindVariableRender` is the `BindVariableRender`
implementation class for rendering bind variable to 「`:variable name`」 format(e.g. `:id`). This class is available since 1.0.2.

[source,properties]
.How to enable via configuration properties file (mybatis-thymeleaf.properties)
----
dialect.bind-variable-render = org.mybatis.scripting.thymeleaf.support.spring.SpringNamedParameterBindVariableRender
----

[source,java]
.How to enable via configuration class (SqlGeneratorConfig)
----
SqlGeneratorConfig config = SqlGeneratorConfig.newInstanceWithCustomizer(c ->
    c.getDialect().setBindVariableRender(
        BindVariableRender.BuiltIn.SPRING_NAMED_PARAMETER.getType()));
SqlGenerator sqlGenerator = new SqlGenerator(config);
----


== Cautions for usage

[CAUTION]
====
The Thymeleaf 3 does not provide the template mode for SQL.
Therefore there are some cautions for usage.
====

=== Using '\'(backslash)

If you are using 2-way SQL mode, there is case that cannot parse a 2-way SQL when specify `'\'`(backslash) within static template parts.
We know that following case cannot be parsed 2-way SQL. If you are not using 2-way SQL mode, this limitation can be ignore.

==== ESCAPE clause for LIKE

If you specify the `ESCAPE '\'` directly as static template parts, the Thymeleaf cannot parse it.

[source,sql]
.Invalid usage
----
/*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/
AND firstName LIKE /*[('#{patternFirstName}')]*/ 'Taro%' /**/ ESCAPE '\' --<1>
----

<1> Specify the `ESCAPE '\'` directly as static template parts

[TIP]
====
As a solution for avoiding this behavior,
the mybatis-thymeleaf provide the expression utility method for adding the `ESCAPE` clause.
For detail, please see <<escapeClause>>.
====


== Appendix

=== Configuration properties

The mybatis-thymeleaf provides following properties for customizing configurations.

[cols="3,4,^1,2",options="header"]
.Supported property list
|===
^|Property Key
^|Description
^|Type
^|Default value

4+|*General configuration*

|`use2way`
|Whether use the 2-way SQL feature
|`Boolean`
|`true` (enable the 2-way SQL feature)

|`customizer`
|The FQCN of class that implements the `TemplateEngineCustomizer`
(interface for customizing a default TemplateEngine instanced by the mybatis-thymeleaf)
|`Class`
|`null` (This instance is do-nothing)

4+|*Template file configuration*


|`template-file.cache-enabled`
|Whether use the cache feature when load template resource file
|`Boolean`
|`true` (enable template cache feature)

|`template-file.cache-ttl`
|The cache TTL(millisecond) for resolved templates
|`Long`
|`null` (no TTL)

|`template-file.encoding`
|The character encoding for reading template resource file
|`String`
|`"UTF-8"`

|`template-file.base-dir`
|The base directory for reading template resource file
|`String`
|`""` (just under class path)

|`template-file.patterns`
|The patterns for reading as template resource file
(Can specify multiple patterns using comma(`","`) as separator character)
|`String[]`
|`"*.sql"`

4+|*Template file path provider configuration for TemplateFilePathProvider* +
(Available only at `ThymeleafLanguageDriverConfig`)

|`template-file.path-provider.prefix`
|The prefix for adding to template file path
|`String`
|`""`

|`template-file.path-provider.includes-package-path`
|Whether includes package path part
|`Boolean`
|`true` (includes package path)

|`template-file.path-provider.separate-directory-per-mapper`
|Whether separate directory per mapper
|`Boolean`
|`true` (separate directory per mapper)

|`template-file.path-provider.includes-mapper-name-when-separate-directory`
|Whether includes mapper name into file name when separate directory per mapper
|`Boolean`
|`true` (includes mapper name)

|`template-file.path-provider.cache-enabled`
|Whether cache a resolved template file path
|`Boolean`
|`true` (cache a resolved template file path)

4+|*Dialect configuration*

|`dialect.prefix`
|The prefix name of dialect provided by this project
|`String`
|`"mb"`

|`dialect.like-escape-char`
|The escape character for wildcard of LIKE condition
|`Character`
|`'\'` (backslash)

|`dialect.like-escape-clause-format`
|The format of escape clause for LIKE condition
(Can specify format that can be allowed by `String#format` method)
|`String`
|`"ESCAPE '%s'"`

|`dialect.like-additional-escape-target-chars`
|Additional escape target characters(custom wildcard characters) for LIKE condition
(Can specify multiple characters using comma(`","`) as separator character)
|`Character[]`
|`""` (no specify)

|`dialect.bind-variable-render`
|The FQCN of class that implements the `BindVariableRender`
(interface for rendering a bind variable such as `#{id}`, `:id`, etc...)
|`Class`
|`null` (Uses render class for MyBatis)
|===

[source,properties]
.src/main/resources/mybatis-thymeleaf.properties
----
use2way = false
customizer = com.example.MyTemplateEngineCustomizer
template-file.cache-enabled = true
template-file.cache-ttl = 3600000
template-file.encoding = UTF-8
template-file.base-dir = templates/
template-file.patterns = *sql, *.sql.template
template-file.path-provider.prefix = sqls/
template-file.path-provider.includes-package-path = false
template-file.path-provider.separate-directory-per-mapper = false
template-file.path-provider.includes-mapper-name-when-separate-directory = false
dialect.prefix = mybatis
dialect.like-escape-char = ~
dialect.like-escape-clause-format = escape '%s'
dialect.like-additional-escape-target-chars = ％, ＿
dialect.bind-variable-render = org.mybatis.scripting.thymeleaf.support.spring.SpringNamedParameterBindVariableRender
----

[TIP]
====
These properties can be specified via factory method of `ThymeleafLanguageDriverConfig` as follow:

[source,java]
----
configuration.getLanguageRegistry().register(
  new ThymeleafLanguageDriver(ThymeleafLanguageDriverConfig.newInstance(c -> {
  c.setUse2way(false);
  c.setCustomizer(CustomTemplateEngineCustomizer.class);
  c.getTemplateFile().setCacheEnabled(false);
  c.getTemplateFile().setCacheTtl(3600000L);
  c.getTemplateFile().setEncoding(StandardCharsets.UTF_8);
  c.getTemplateFile().setBaseDir("templates/");
  c.getTemplateFile().setPatterns("*.sql", "*.sql.template");
  c.getTemplateFile().getPathProvider().setPrefix("sqls/");
  c.getTemplateFile().getPathProvider().setIncludesPackagePath(false);
  c.getTemplateFile().getPathProvider().setSeparateDirectoryPerMapper(false);
  c.getTemplateFile().getPathProvider()
      .setIncludesMapperNameWhenSeparateDirectory(false);
  c.getDialect().setPrefix("mybatis");
  c.getDialect().setLikeEscapeChar('~');
  c.getDialect().setLikeEscapeClauseFormat("escape '%s'");
  c.getDialect().setLikeAdditionalEscapeTargetChars('％', '＿');
  c.getDialect().setBindVariableRender(
      BindVariableRender.BuiltIn.SPRING_NAMED_PARAMETER.getType());
})));
----

If you specify the value both with properties file and customizer function, the properties file value applied.
We provide following factory methods for creating a `ThymeleafLanguageDriver` instance.

* `newInstance()`
* `newInstance(String resourcePath)`
* `newInstance(Properties customProperties)`
* `newInstance(Consumer<ThymeleafLanguageDriverConfig> customizer)`

These properties can be specified via factory method of `SqlGeneratorConfig` as follow:

[source,java]
----
SqlGeneratorConfig config =
  SqlGeneratorConfig.newInstanceWithCustomizer(c -> {
  c.setUse2way(false);
  c.setCustomizer(CustomTemplateEngineCustomizer.class);
  c.getTemplateFile().setCacheEnabled(false);
  c.getTemplateFile().setCacheTtl(3600000L);
  c.getTemplateFile().setEncoding(StandardCharsets.UTF_8);
  c.getTemplateFile().setBaseDir("templates/");
  c.getTemplateFile().setPatterns("*.sql", "*.sql.template");
  c.getDialect().setPrefix("mybatis");
  c.getDialect().setLikeEscapeChar('~');
  c.getDialect().setLikeEscapeClauseFormat("escape '%s'");
  c.getDialect().setLikeAdditionalEscapeTargetChars('％', '＿');
  c.getDialect().setBindVariableRender(
      BindVariableRender.BuiltIn.SPRING_NAMED_PARAMETER.getType());
});
// ...
----

We provide following factory methods for creating a `SqlGeneratorConfig` instance.

* `newInstance()`
* `newInstanceWithResourcePath(String resourcePath)`
* `newInstanceWithProperties(Properties customProperties)`
* `newInstanceWithCustomizer(Consumer<SqlGeneratorConfig> customizer)`

====


=== Bulk insert

This section describe about bulk insert for collection or array using SQL rather than JDBC feature.
If you want to insert a collection or array by bulk, you can be realized it using the `th:each` and `mb:p` attribute tags as follow:


[source,java]
.Domain objects
----
public class Person {
  private int id;
  private String firstName;
  private String lastName;
  private LocalDate dateOfBirth;
  private List<Mail> mails;
  // ...
}
public class Mail {
  private int id;
  private int personId;
  private String address;
  // ...
}
----

[source,java]
.Mapper methods
----
@Options(useGeneratedKeys = true, keyProperty = "id")
@Insert("sqls/PersonMapper_insertByBulk.sql")
void insertByBulk(List<Person> persons);

@Insert("sqls/PersonMapper_insertMailsByBulk.sql")
void insertMailsByBulk(List<Person> persons);
----

[source,sql]
.SQL template for top level collection/array
----
INSERT INTO persons
  (first_name, last_name, date_of_birth)
VALUES
/*[# th:each="person : ${list}"]*/ -- <1>
  (
    /*[# mb:p="person.firstName"]*/ 'Taro' /*[/]*/, -- <2>
    /*[# mb:p="person.lastName"]*/ 'Yamada' /*[/]*/,
    /*[# mb:p="person.dateOfBirth"]*/ '2000-03-28' /*[/]*/
  )/*[(${personStat.last} ? '' : ',')]*/
/*[/]*/
----

[source,sql]
.SQL template for nested property collection/array
----
INSERT INTO person_mails
  (person_id, address)
VALUES
/*[# th:each="person : ${list}"]*/ -- <1>
  /*[# th:each="mail : ${person.mails}"]*/ -- <3>
    (
      /*[# mb:p="person.id"]*/ 1 /*[/]*/,
      /*[# mb:p="mail.address"]*/ 'taro.yamada@mybatis.org' /*[/]*/ -- <4>
    )/*[(${personStat.last and mailStat.last} ? '' : ',')]*/
  /*[/]*/
/*[/]*/
----

<1> Fetch and store to local variable(e.g. `person`) an element object of top level collection/array using `th:each`
<2> Specify a property of element object fetched from top level collection/array as bind variable using `mb:p`
<3> Fetch and store to local variable(e.g. `mail`) and element object of nested property collection or array
<4> Specify a property of element object fetched from nested property collection/array as bind variable using `mb:p`

The `mb:p` register an element object that fetched from collection/array to the MyBatis’s bind variables.


=== Multiline String Literals

You can specify an SQL in annotation using "link:https://openjdk.java.net/jeps/355[Text Blocks^]" feature that support by future JDK version.
Also,"Multiline String Literals" provided other JVM languages (such as Kotlin and Groovy) can be used.
There is a good compatibility with annotation driven mapper.

==== Java

* link:https://openjdk.java.net/jeps/355[Text Blocks^]

[source,java]
----
@Select("""
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
""")
Name findById(Integer id);
----

==== Kotlin

* link:https://kotlinlang.org/docs/reference/basic-types.html#string-literals[String Literals^]

[source,kotlin]
.Kotlin
----
@Select("""
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
""")
fun findById(id: Int): Name
----

==== Groovy

* link:http://docs.groovy-lang.org/latest/html/documentation/#_triple_single_quoted_string[Triple single quoted string^]

[source,groovy]
.Groovy
----
@Select('''
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
''')
Todo findById(int id);
----

=== Related resources


[cols="2,8",options="header"]
.Related resource list
|===
^|Resource name
^|Description

|link:{github-url}[GiHub Page^]
|The mybatis-thymeleaf GiHub top page

|link:{github-wiki-url}/Usage-on-framework[Usage on framework^]
|Explain how to integrate with an application framework

|link:{github-wiki-url}/Code-completion[Code completion^]
|Explain about code completion

|link:{github-wiki-url}/Quick-Start[Quick Start^]
|Explain how to use mybatis-thymeleaf quickly using the Spring Boot
|===

