[[user-guide]]
= MyBatis Thymeleaf User's Guide
:author: The MyBatis Team
:revnumber: x.x.x
:revdate: {localdate}
:toc: left
:icons: font
:source-highlighter: coderay
:imagesdir: ./images
:imagesoutdir: ./images
:docinfodir: ./docinfos
:docinfo1:
:sectnums:
:nofooter:
:sectlinks:
:linkcss:
:xrefstyle: full

// Define variable for urls
:mybatis-doc-url: http://www.mybatis.org/mybatis-3
:travis-ci-url: https://travis-ci.org/mybatis/thymeleaf-scripting
:mybatis-spring-boot-doc-url: http://www.mybatis.org/spring-boot-starter
:thymeleaf-doc-url: https://www.thymeleaf.org/doc/tutorials/3.0
:github-organization-url: https://github.com/mybatis

// Define dependency artifact versions
:mybatis-version: y.y.y

== Overview

=== What is MyBatis Thymeleaf ?

The mybatis-thymeleaf is a plugin that helps applying the 2-way SQL/dynamic SQL feature to the MyBatis 3
using the template(or natural template) mechanism provided by Thymeleaf 3.
If you are not familiar with MyBatis and Thymeleaf, you can see following official documentations.

* {mybatis-doc-url}[MyBatis 3 REFERENCE DOCUMENTATION^]
* {thymeleaf-doc-url}/usingthymeleaf.html[Tutorial: Using Thymeleaf^]
* {thymeleaf-doc-url}/usingthymeleaf.html#textual-template-modes[Tutorial: Using Thymeleaf -13 Textual template modes-^]

=== What is 2-way SQL?

The 2-way SQL can be used by following *two way*.

* It can be executed as-is in SQL execution tool (such as psql, mysql, sqlplus, plugins for IDE, etc...)
* It can be used as a SQL template for creating a bindable and dynamically SQL on your application

==== Simple bindable 2-way SQL

The mybatis-thymeleaf translate a simple bindable 2-way SQL that specified by natural template to as follow:


[source,sql]
.SQL Template using custom attribute tag provided by mybatis-thymeleaf
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----

[source,sql]
.SQL Template using only Thymeleaf standard feature
----
SELECT * FROM names
  WHERE id = /*[('#{id}')]*/ 1
----

==== Dynamically bindable 2-way SQL

The mybatis-thymeleaf translate a dynamically bindable 2-way SQL that specified by natural template to as follow:

[source,sql]
.SQL Template using custom attribute tag provided by mybatis-thymeleaf
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/)
  /*[/]*/
  ORDER BY id
----

f you use only the Thymeleaf standard feature, an above tempalte can be replaced following template

[source,sql]
.SQL Template using only Thymeleaf standard feature
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (
    /*[# th:each="id : ${ids}"]*/
      /*[('#{ids[' + ${idStat.index} + ']}')]*/ 1
      /*[(${idStat.last} ? '' : ',')]*/
    /*[/]*/
    )
  /*[/]*/
  ORDER BY id
----

==== Dynamically bindable SQL

The mybatis-thymeleaf translate a dynamically bindable SQL(non 2-way SQL) that specified by template to as follow:

[source,sql]
.SQL Template using custom attribute tag provided by mybatis-thymeleaf
----
-- Use the custom tag provided by mybatis-thymeleaf
SELECT * FROM names
  WHERE 1 = 1
  [# th:if="${not #lists.isEmpty(ids)}"]
    AND id IN ([# mb:p="ids" /])
  [/]
  ORDER BY id
----

[source,sql]
.SQL Template using only Thymeleaf standard feature
----
SELECT * FROM names
  WHERE 1 = 1
  [# th:if="${not #lists.isEmpty(ids)}"]
    AND id IN (
    [# th:each="id : ${ids}"]
      [('#{ids[' + ${idStat.index} + ']}')]
      [(${idStat.last} ? '' : ',')]
    [/]
    )
  [/]
  ORDER BY id
----


=== Mainly Features

The mybatis-thymeleaf provide following features using class that implements
the link:{mybatis-doc-url}/dynamic-sql.html#Pluggable_Scripting_Languages_For_Dynamic_SQL[`LanguageDriver` interface^]
for integrating with template engine provide by Thymeleaf.

* Can write 2-way SQL/dynamic SQL
* Can use a 2-way SQL/dynamic SQL via an annotation and mapper xml
* Can read an SQL template from a template file on classpath
* Can use a custom dialect(attribute tag and expression utility method) at a template
* Can fully customize a template engine configuration


== Requirements

The mybatis-thymeleaf supports using on following Java and artifacts version.

=== Java

* Java 8, Java 11+

[NOTE]
====
About tested versions see the latest link:{travis-ci-url}[Travi CI^] build result.
====

=== MyBatis

* MyBatis 3.4.3+

[NOTE]
====
As basically policy, we do test using following versions.

* latest release version on 3.5.x line
* latest snapshot version on 3.5.x line
* latest release version on 3.4.x line
====

=== Thymeleaf

* Thymeleaf 3.0+

[NOTE]
====
As basically policy, we do test using following versions.

* latest release version on 3.0.x line
====

== Getting Started

In this chapter, we explain basic usage of the mybatis-thymeleaf.

=== Installation

==== Maven

If you are using the Maven as build tool, you can add as follow:

[source,xml,subs="specialchars,attributes"]
.pom.xml (dependencies)
----
<dependencies>
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>{mybatis-version}</version> <!-- Adjust to your application -->
  </dependency>
  <dependency>
    <groupId>org.mybatis.scripting</groupId>
    <artifactId>mybatis-thymeleaf</artifactId>
    <version>{revnumber}</version>
  </dependency>
</dependencies>
----

If you use a snapshot version, you need add the configuration
for using the "Sonatype OSS Snapshots Repository" as follow:

[source,xml,subs="specialchars,attributes"]
.pom.xml (repositories)
----
<repositories>
  <repository>
    <id>sonatype-oss-snapshots</id>
    <name>Sonatype OSS Snapshots Repository</name>
    <url>https://oss.sonatype.org/content/repositories/snapshots</url>
  </repository>
</repositories>
----

==== Gradle

If you are using the Gradle as build tool, you can add as follow:

[source,groovy,subs="specialchars,attributes"]
.build.gradle (dependencies)
----
dependencies {
  compile("org.mybatis:mybatis:{mybatis-version}") // Adjust version to your application
  compile("org.mybatis.scripting:mybatis-thymeleaf:{revnumber}")
}
----

If you use a snapshot version, you need add the configuration for using the "Sonatype OSS Snapshots Repository" as follow:

[source,groovy,subs="specialchars,attributes"]
.build.gradle (repositories)
----
repositories {
  maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
}
----

=== Configuration

Set the `ThymeleafLanguageDriver` as your default scripting language to MyBatis.

[source,java]
.Configuration class (Java based configuration)
----
Configuration configuration = new Configuration();
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class);
----

[source,xml]
.mybatis-config.xml (XML based configuration)
----
<settings>
  <setting name="defaultScriptingLanguage"
           value="org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"/>
</settings>
----

=== Creating Mapper

The MyBatis provides two ways(annotation driven and XML driven) for creating a Mapper.

==== Annotation driven mapper

If you use the annotation driven mapper, you can specify an SQL as follow:

[source,java]
.src/main/java/com/example/NameMapper.java
----
public class NameMapper {
  @Select("SELECT * FROM names WHERE id = /*[# mb:p='id']*/ 1 /*[/]*/")
  Name findById(Integer id);
}
----

[TIP]
====
You can specify a readable SQL on annotation using "Multiline String Literals" provided by some JVM language.
About "Multiline String Literals", please see the <<Multiline String Literals>>.
====


Also, you can specify an SQL on template file(e.g. `/NameMapper/findById.sql` on class path) as follow:

[source,java]
----
@Select("/NameMapper/findById.sql")
Name findById(Integer id);
----

By default behavior, the mybatis-thymeleaf read a specified template file from just under classpath.

[[_getting-started-template-sql]]
[source,sql]
.src/main/resources/NameMapper/findById.sql
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----

==== XML driven mapper

If you use the XML driven mapper, you can specify an SQL on mapper XML file as follow:

[source,java]
.src/main/java/com/example/NameMapper.java
----
public class NameMapper {
  Name findById(Integer id);
}
----

[source,xml]
.src/main/resources/com/example/NameMapper.xml
----
<mapper namespace="com.example..NameMapper">
  <select id="findById" resultType="com.example.Name">
    <![CDATA[
    SELECT * FROM names
      WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
    ]]>
  </select>
</mapper>
----

Also, you can specify an SQL on template file
(see '<<_getting-started-template-sql,Annotation driven mapper>>' section) as follow:

[source,xml]
----
<select id="findById" resultType="com.example.Name">
  /NameMapper/findById.sql
</select>
----

== Configuration

In this chapter, we explain a way for applying mybatis-thymeleaf to the MyBatis in detail.
About MyBatis core module configuration,
please see the {mybatis-doc-url}/configuration.html[MyBatis reference document^].

=== Basic configuration

You configure to use the `org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver` as scripting language driver.

==== Java based configuration

[source,java]
.Configuration class
----
Configuration configuration = new Configuration();
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class); // <1>
// ...
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
----

<1> Set the `ThymeleafLanguageDriver` class to a `Configuration` instance as default scripting language driver

==== XML based configuration

[source,xml]
.src/main/resources/mybatis-config.xml
----
<settings>
  <setting name="defaultScriptingLanguage"
           value="org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver"/> // <1>
</settings>
----

[source,java]
----
SqlSessionFactory sqlSessionFactory;
try (Reader configReader = Resources.getResourceAsReader("mybatis-config.xml")) {
  sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader);
}
----

<1> Set the `ThymeleafLanguageDriver` class to the `defaultScriptingLanguage` of setting item in configuration XML file

=== Customizing configuration

The mybatis-thymeleaf provides three ways for customizing template engine configuration.

* <<Using properties file>>
* <<Using functional interface>>
* <<Using user-defined template engine>>

==== Using properties file

The mybatis-thymeleaf provide the special properties file for customizing default configuration.
By default behavior, the mybatis-thymeleaf load the `mybatis-thymeleaf.properties` stored just under classpath.
About supported properties, please see the <<Configuration properties>>.

===== Using an any properties file

You can use an any properties file instead of the default properties file.
If you use an any properties file, please specify a properties file using
the special system properties(`mybatis-thymeleaf.config.file`) as follow:

[source,text]
----
$ java -Dmybatis-thymeleaf.config.file=mybatis-thymeleaf_production.properties ...
----

===== Using an any file encoding

You can use an any file encoding instead of the default file encoding(`UTF-8`).
If you use an any file encoding, please specify a file encoding using
the special system properties(`mybatis-thymeleaf.config.encoding`) as follow:

[source,text]
----
$ java -Dmybatis-thymeleaf.config.encoding=Windows-31J ...
----

==== Using functional interface

The mybatis-thymeleaf provide the special functional
interface(`org.mybatis.scripting.thymeleaf.TemplateEngineCustomizer`) for customizing configurations using Java code.
This feature provide an opportunity to customize configuration that cannot customize it using properties file.

[source,java]
.src/main/java/com/example/MyTemplateEngineCustomizer.java
----
public class MyTemplateEngineCustomizer implements TemplateEngineCustomizer {
  @Override
  public void customize(TemplateEngine defaultTemplateEngine) {
    // ... <1>
  }
}
----

[source,properties]
.src/main/resources/mybatis-thymeleaf.properties
----
customizer = com.example.MyTemplateEngineCustomizer # <2>
----

<1> Write a Java code for customizing template engine

<2> Specify a FQCN of customizer class in `mybatis-thymeleaf.properties`

==== Using user-defined template engine

When your application requirements cannot be satisfied using above customizing features,
you can apply a user-defined template engine(full managed template engine) to the mybatis-thymeleaf as follow:

[source,java]
.Configuration class
----
TemplateEngine templateEngine = new TemplateEngine(); // <1>
templateEngine.addDialect(new MyBatisDialect());
templateEngine.setEngineContextFactory(new MyBatisIntegratingEngineContextFactory(
    targetTemplateEngine.getEngineContextFactory()));
// ...

Configuration configuration = new Configuration();
configuration.getLanguageRegistry()
    .register(ThymeleafLanguageDriver.newBuilder().templateEngine(templateEngine).build()); // <2>
configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class); // <3>
----

<1> Create an instance of class that implements `org.thymeleaf.ITemplateEngine`

<2> Register an instance of `ThymeleafLanguageDriver` that associate with user-defined template engine instance

<3> Set the `ThymeleafLanguageDriver` class as default scripting language driver

== Writing 2-way SQL

In this section, we explain standard usage of 2-way SQL.

[CAUTION]
====
About cautions for usage 2-way SQL, please see the <<Cautions for usage>>.
====


=== Binding value

The mybatis-thymeleaf use the default binding feature provided by MyBatis core module.
Therefore, you need to write a 2-way SQL template for generating string
that can be parsed by MyBatis core module as follow:

[source,sql]
.About default binding feature provided by MyBatis
----
SELECT * FROM names
  WHERE id = #{id} -- <1>
----

[source,sql]
.2-way SQL template for generating string that can be parsed by MyBatis core module
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/ -- <2>
----

<1> A bind value is specified by `#{variable name}` format
<2> Can render bind variable expression that can be parsed by MyBatis core module using custom attribute tag(`mb:p="variable name"`) provided by mybatis-thymeleaf

[NOTE]
====
**What can you bind?**

Basically, you can bind a parameter object(Mapper method arguments or `SqlSession` method arguments).
In addition, the mybatis-thymeleaf allow to be bind a registered value using `mb:bind` tag.
About usage of `mb:bind`, please see <<Attribute tag>>.
====

=== Dynamic SQL

The Thymeleaf supports to create an any string dynamically using conditional evaluation
and iterating evaluation feature. By using this feature, you can write a dynamic 2-way SQL.

* <<Using tag for specifying condition>>
* <<Using tag for iteration>>

==== Using tag for specifying condition

If you add a SQL part when any condition is matches or not, you can use following attribute tags.

* `th:if`
* `th:unless` (denial version for `th:if`)
* `th:switch`
* `th:case`

[source,sql]
.Usage of conditional attribute tag on WHERE
----
SELECT * FROM names
  WHERE 1 = 1 -- <1>
  /*[# th:if="${firstName} != null"]*/ -- <2>
    AND firstName = /*[# mb:p="firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/ -- <3>
  ORDER BY id
----

[source,sql]
.Usage of conditional attribute tag on SET
----
UPDATE names
  SET id = id -- <4>
  /*[# th:if="${firstName} != null"]*/
    , firstName = /*[# mb:p="firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
----

<1> Specify a non-dynamic condition at first position because the mybatis-thymeleaf does not provide
    the trimming feature such as `<where>` of XML based scripting language

<2> Specify a condition on start tag using natural template

<3> Specify an end tag of condition

<4> Specify a non-dynamic updating column at first position because the mybatis-thymeleaf does not provide
    the trimming feature such as `<set>` of XML based scripting language

==== Using tag for iteration

The Thymeleaf supports to process for iteration object(`List` etc..) using `th:each`.

[source,sql]
.Basic usage of iteration tag
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (
    /*[# th:each="id : ${ids}"]*/ -- <1>
      /*[# mb:p="id"]*/ 1 /*[/]*/ -- <2>
      /*[(${idStat.last} ? '' : ',')]*/ -- <3>
    /*[/]*/ -- <4>
    )
  /*[/]*/
  ORDER BY id
----

<1> Specify an iterable object on `th:each`

<2> Specify a 2-way SQL of binding value per iterable element.
    A bind value specify by `mb:p="{variable name of iterable element}"` format.

<3> Append comma character when element position is not last.
    You can access an iteration status object (`IterationStatusVar`) that named by `"{variable name of iterable element}Stat"` format.

<4> Specify an end tag of iteration

[TIP]
====
Also, an above SQL template can be replaced using `mb:p` attribute tag with following SQL template.


[source,sql]
.Use `mb:p` for creating bind variables string of IN clause
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${not #lists.isEmpty(ids)}"]*/
    AND id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/)
  /*[/]*/
  ORDER BY id
----
====

About more advanced usage, please see <<Bulk insert>>.

=== Fragment

The Thymeleaf supports to insert template string from an another template file.
By using this feature, you can share a 2-way SQL on multiple SQL template.

The standard use case using this feature is paging query as follow:

[source,java]
.Mapper
----
// Count a total record number that matches for criteria
@Select("/NameMapper/countByCriteria.sql")
long countByCriteria(@Param("criteria") NameCriteria criteria);

// Search records that matches for criteria and specified page
@Select("/NameMapper/findPageByCriteria.sql")
List<Name> findPageByCriteria(@Param("criteria") NameCriteria criteria, @Param("pageable") Pageable pageable);
----

.src/main/resources/NameMapper/countByCriteria.sql
[source,sql]
----
SELECT COUNT(*) FROM names
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
----

.src/main/resources/NameMapper/findPageByCriteria.sql
[source,sql]
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
  LIMIT /*[# mb:p="pageable.pageSize"]*/ 20 /*[/]*/
  OFFSET /*[# mb:p="pageable.offset"]*/ 0 /*[/]*/
  ORDER BY id
----

Probably looking at above SQLs many developers will look for a way to share the `WHERE` clause.
In such case, you can share any SQL part by multiple SQL using fragment feature.

==== Creating a fragment SQL

At first, you create a fragment SQL template file for sharing by multiple SQL as follow:

.src/main/resources/NameMapper/whereByCriteria.sql
[source,sql]
----
/*[- */ -- <1>
SELECT * FROM names
/* -]*/ -- <2>
  WHERE 1 = 1
  /*[# th:if="${criteria.firstName} != null"]*/
    AND firstName = /*[# mb:p="criteria.firstName"]*/ 'Taro' /*[/]*/
  /*[/]*/
  /*[# th:if="${criteria.lastName} != null"]*/
    AND lastName = /*[# mb:p="criteria.lastName"]*/ 'Yamada' /*[/]*/
  /*[/]*/
----

<1> Start a block comment for ignoring `"SELECT * FROM names"` part at template processing time
<2> End a block comment

==== Insert a fragment SQL

You can insert a fragment SQL template file on each template as follow:

.src/main/resources/NameMapper/countByCriteria.sql
[source,sql]
----
SELECT COUNT(*) FROM names
  /*[# th:insert="~{/NameMapper/whereByCriteria.sql}" /]*/ -- <1>
----

.src/main/resources/NameMapper/findPageByCriteria.sql
[source,sql]
----
SELECT * FROM names
  /*[# th:insert="~{/NameMapper/whereByCriteria.sql}" /]*/ -- <1>
  LIMIT /*[# mb:p="pageable.pageSize"]*/ 20 /*[/]*/
  OFFSET /*[# mb:p="pageable.offset"]*/ 0 /*[/]*/
  ORDER BY id
----

<1> Insert a fragment SQL template file

=== Special variables

The mybatis and mybatis-thymeleaf provides special variables that prefixed with `_` as follows:

[cols="2,7,1",options="header"]
.Special variables
|===
^|Variable Name
^|Description
^|Type

|`_parameter`
|The parameter object that passed to the MyBatis
|Any type

|`_databaseId`
|The id for identifying the database
(If you want to this variable, you should be enabled the link:{mybatis-doc-url}/configuration.html#databaseIdProvider[`DatabaseIdProvider` feature^] on MyBatis)
|`String`
|===

=== Using configuration properties

You can access the configuration properties of MyBatis from your SQL template.
About configuration properties, please see the link:{mybatis-doc-url}/configuration.html#properties[MyBatis reference documentation^].

[source,java]
.Java based configuration
----
Configuration configuration = new Configuration();
Properties variables = new Properties();
variables.setProperty("tableNameOfUser", "accounts"); // <1>
configuration.setVariables(variables);
----

[source,xml]
.XML based configuration (mybatis-config.xml)
----
<properties>
  <property name="tableNameOfUser" value="accounts"/> <!--1-->
</properties>
----

[source,sql]
.SQL template
----
SELECT * FROM /*[(${tableNameOfUser} ?: 'users')]*/ users -- <2>
----

<1> Define an any property as MyBatis's configuration properties
<2> Access a configuration property using Thymeleaf's expression

Above SQL template translate to as follows:

[source,sql]
.Translated SQL (when `tableNameOfUser` is defined)
----
SELECT * FROM accounts
----

[source,sql]
.Translated SQL (when `tableNameOfUser` is not defined)
----
SELECT * FROM users
----


== Cautions for usage

[CAUTION]
====
The Thymeleaf 3 does not provide the template mode for SQL.
Therefore there are some cautions for usage.
====

=== 2-way SQL format

If you use a binding value using 2-way SQL format without `mb:p` custom tag,
there is case that cannot translate correctly 2-way SQL when specify multiple item on one line as follow:

[source,sql]
.Invalid format
----
SELECT * FROM names
  WHERE id = /*[('#{id}')]*/ 1 AND version = /*[('#{version}')]*/ 1
----

You can resolve it that add a line break chars between with each conditions as follow:

[source,sql]
.Valid format
----
SELECT * FROM names
  WHERE id = /*[('#{id}')]*/ 1 -- <1>
  AND version = /*[('#{version}')]*/ 1
----

<1> Add the line break chars(LF or CRLF) between with each conditions

Alternatively, you can resolve it that specify the empty comment between with each conditions as follow:

[source,sql]
.Valid format
----
SELECT * FROM names
  WHERE id = /*[('#{id}')]*/ 1 /**/ AND version = /*[('#{version}')]*/ 1 -- <1>
----

<1> Add the empty SQL comment(`/**/`) between each conditions

[NOTE]
====
We known that threre is no problem using on `VALUES` and `SET` clause as follows:

[source,sql]
.Valid format on VALUES
----
INSERT INTO names (firstName, lastName)
  VALUES (/*[('#{firstName}')]*/ 'Taro' ,/*[('#{lastName}')]*/ 'Yamada')
----

[source%nowrap,sql]
.Valid format on SET
----
UPDATE names
  SET firstName = /*[('#{firstName}')]*/ 'Taro' ,lastName = /*[('#{lastName}')]*/ 'Yamada'
  WHERE id = /*[('#{id}')]*/ 1
----

However, the following 2-way SQL is invalid.

[source,sql]
.Invalid format
----
UPDATE names
  SET firstName = /*[('#{firstName}')]*/ 'Taro'
     ,lastName = /*[('#{lastName}')]*/ 'Yamada' WHERE id = /*[('#{id}')]*/ 1 -- <1>
----

<1> Cannot specify the `WHERE` clause after the 2-way SQL on same line
    (Even in this case, you can resolve it that specify the empty comment(`/**/`) before the `WHERE` clause)

====

=== Using '\'(backslash)

If you are using 2-way SQL mode, there is case that cannot parse a 2-way SQL when specify `'\'`(backslash) within static template parts.
We know that following case cannot be parsed 2-way SQL. If you are not using 2-way SQL mode, this limitation can be ignore.

==== ESCAPE clause for LIKE

If you specify the `ESCAPE '\'` directly as static template parts, the Thymeleaf cannot parse it.

[source,sql]
.Invalid usage
----
/*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/
AND firstName LIKE /*[('#{patternFirstName}')]*/ 'Taro%' /**/ ESCAPE '\'
----

<1> Specify the `ESCAPE '\'` directly as static template parts

[TIP]
====
As a solution for avoiding this behavior,
the mybatis-thymeleaf provide the expression utility method for adding the `ESCAPE` clause.
For detail, please see <<escapeClause>>.
====

== Custom Dialect

The mybatis-thymeleaf provide the custom dialect class(`org.mybatis.scripting.thymeleaf.MyBatisDialect`)
that help for generating dynamic SQL.

=== Attribute tag

By default, you can use it using `mb` dialect prefix (default prefix is initial letter of "**M**y**B**atis").

[cols="2,4,4",options="header"]
.Supported method list
|===
^|Attribute Tag Name
^|Description
^|Attribute Value Format

|<<mybatis-param,p>>
a|Render bind variable(`#{...}`) that can parsed MyBatis and register an iteration object to the MyBatis's bind variables.
a|`{variableName}(,{optionKey}={optionValue},...)` +
 +
 Valid format is same with link:{mybatis-doc-url}/sqlmap-xml.html#Parameters[MyBatis's inline parameter format^].

|<<mybatis-bind,bind>>
|Register an any value to the MyBatis's bind variables
(Provides a feature similar to that of the link:{mybatis-doc-url}/dynamic-sql.html#bind[`<bind>`^] provided by MyBatis core module)
a|`{variable name}={variable value}(,...)` +
 +
 Valid format is same with `th:with` provided by Thymeleaf.
|===

[[mybatis-param]]
==== p

[source,sql]
.Basic usage:
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/ -- <1>
----

[source,sql]
.Usage with option:
----
SELECT * FROM names
  WHERE id = /*[# mb:p="id,typeHandler=com.example.IdTypeHandler"]*/ 1 /*[/]*/ -- <2>
----

[source,sql]
.Usage for collection and array:
----
SELECT * FROM names
  WHERE id IN (/*[# mb:p="ids"]*/ 1 /*[/]*/) -- <3>
----

<1> Render single bind variable(e.g. `#{id}`) that can parsed MyBatis when specify a simple value object
<2> Can specify parameter options(`key=value` format) separate with comma
<3> Render multiple bind variables(e.g. `#{ids[0]}, #{ids[1]}, ...`) that can parsed MyBatis when specify a collection or array object


[[mybatis-bind]]
==== bind

[source,sql]
.Basic usage:
----
SELECT * FROM names
  WHERE 1 = 1
  /*[# th:if="${firstName} != null"]*/
    /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/ -- <1>
    AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro' /*[/]*/ -- <2>
  /*[/]*/
----

[source,sql]
.Usage for registering multiple variables:
----
/*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|, patternLastName=|${#likes.escapeWildcard(lastName)}%|" /]*/ -- <3>
----

<1> Register an any value(e.g. editing value at template) as custom bind variables
<2> Bind a custom bind variable
<3> Also, you can register multiple custom bind variables separating with comma at the same time

[NOTE]
====
*Why need the bind tag?*

The binding feature provide by MyBatis cannot access a variable that shared by the `th:with`
because it can only access within a template. Hence, the mybatis-thymeleaf provide the `bind` attribute tag.
====

=== Expression utility method

==== #likes expression

The `#likes` expression provide utility methods for LIKE clause.

[cols="1,5a,4",options="header"]
.Supported method list
|===
^|Method
^|Arguments
^|Description

|<<mybatis-escapeLikeWildcard,escapeWildcard>>
|

[cols="^1,4,5",options="header"]
!===
^!No
^!Type
^!Description

!1
!String
!A target value
!===

|Return a value that escaped a wildcard character of LIKE condition
(By default behavior, this method escape the `"%"`, `"_"` and `"\"`(escape character itself) using `"\"`)

|<<mybatis-likeEscapeClause,escapeClause>>
| N/A
|Return a escape clause string of LIKE condition
( By default behavior, this method return `"ESCAPE '\'"`)
|===


[TIP]
====
You can customize the default behavior for the `escapeWildcard` and `escapeClause`
using <<Configuration properties, Configuration properties>>.
====


[[mybatis-escapeLikeWildcard]]
===== escapeWildcard

[source,sql]
.Basic usage:
----
/*[# th:if="${firstName} != null"]*/
  /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/ -- <1>
  AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro%' /*[/]*/
/*[/]*/
----

<1> Register a value that escaped wildcard character of LIKE condition as custom bind variables

[source,sql]
.Translate to:
----
  AND firstName LIKE #{patternFirstName}
----


[[mybatis-likeEscapeClause]]
===== escapeClause

[source,sql]
.Basic usage:
----
/*[# th:if="${firstName} != null"]*/
  /*[# mb:bind="patternFirstName=|${#likes.escapeWildcard(firstName)}%|" /]*/
  AND firstName LIKE /*[# mb:p="patternFirstName"]*/ 'Taro%' /*[/]*/ /*[(${#likes.escapeClause()})]*/ -- <1>
/*[/]*/
----

<1> Add `ESCAPE` clause at template processing time

[source,sql]
.Translate to:
----
  AND firstName LIKE #{patternFirstName} ESCAPE '\'
----

== Using non 2-way SQL mode

The non 2-way SQL is simple a little compare with 2-way SQL and limitations not found at now.

=== Configuration

By default, the mybatis-thymeleaf will be use the 2-way SQL mode.
Therefore you should be configure explicitly to use the non 2-way SQL mode using configuration properties file or builder option as follow:

[NOTE]
====
This configuration is optional. The non 2-way SQL can be use on the 2-way SQL mode.
====

[source,properties]
.How to configure using configuration properties file(src/main/resources/mybatis-thymeleaf.properties)
----
use-2way = false # <1>
----

or

[source,java]
.How to configure using builder option
----
configuration.getLanguageRegistry()
    .register(ThymeleafLanguageDriver.newBuilder().use2way(false).build()); // <2>
----

<1> Set the `use-2way` to `false`
<2> Set the `use2way` builder option to `false`


=== Basic usage

The different with the 2-way SQL mode is that will be unnecessary to enclose the thymeleaf expressions as SQL comment(`/\*[...]*/`).

[source,sql]
.SQL Template
----
SELECT * FROM names
  WHERE 1 = 1
  [# th:if="${not #lists.isEmpty(ids)}"]
    AND id IN (
      [# mb:p="ids" /]
    )
  [/]
  ORDER BY id
----

== Usage on framework

In this chapter, we explain ways that integrate with an application framework.

=== Spring Boot

If you are using the {mybatis-spring-boot-doc-url}/mybatis-spring-boot-autoconfigure/index.html[mybatis-spring-boot-starter(Spring Boot)^],
you can configure using configuration properties(properties or yaml file) as follow:

[source%nowrap,properties]
.src/main/resources/application.properties
----
mybatis.configuration.default-scripting-language=org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver
----

[source,yml]
.src/main/resources/application.yml
----
mybatis:
  configuration:
    default-scripting-language: org.mybatis.scripting.thymeleaf.ThymeleafLanguageDriver
----

Also, you can fully customize a template engine using the `ConfigurationCustomizer`.

[source,java]
.Configuration class
----
@Bean
ConfigurationCustomizer mybatisConfigurationCustomizer() {
  return configuration -> {
    TemplateEngine templateEngine = new TemplateEngine(); // <1>
    templateEngine.addDialect(new MyBatisDialect());
    templateEngine.setEngineContextFactory(new MyBatisIntegratingEngineContextFactory(
      targetTemplateEngine.getEngineContextFactory()));
    // ...
    configuration.getLanguageRegistry().register(
        ThymeleafLanguageDriver.newBuilder().templateEngine(templateEngine).build()); // <2>
    configuration.setDefaultScriptingLanguage(ThymeleafLanguageDriver.class); // <3>
  };
}
----

<1> Create an instance of class that implements `org.thymeleaf.ITemplateEngine`

<2> Register an instance of `ThymeleafLanguageDriver` that associate with user-defined template engine instance

<3> Set the `ThymeleafLanguageDriver` class as default scripting language driver instead of
    specifying as configuration properties


== Appendix

=== Configuration properties

The mybatis-thymeleaf provides following properties for customizing configurations.

[cols="1,6,^1,2",options="header"]
.Supported property list
|===
^|Property Key
^|Description
^|Type
^|Default value

4+|*General configuration*

|`use-2way`
|Whether use the 2-way SQL feature
|`Boolean`
|`true` (enable the 2-way SQL feature)

|`customizer`
|The FQCN of class that implements the `TemplateEngineCustomizer`
(interface for customizing a default TemplateEngine instanced by the mybatis-thymeleaf)
|`Class`
|`null` (This instance is do-nothing)

4+|*Template cache configuration*

|`cache.enabled`
|Whether use the cache feature when load template resource file
|`Boolean`
|`true` (enable template cache feature)

|`cache.ttl`
|The cache TTL(millisecond) for resolved templates
|`Long`
|`null` (no TTL)

4+|*Template file configuration*

|`file.character-encoding`
|The character encoding for reading template resource file
|`String`
|`"UTF-8"`

|`file.base-dir`
|The base directory for reading template resource file
|`String`
|`""` (just under class path)

|`file.patterns`
|The patterns for reading as template resource file
(Can specify multiple patterns using comma(`","`) as separator character)
|`String`
|`"*.sql"`

4+|*Dialect configuration*

|`dialect.prefix`
|The prefix name of dialect provided by this project
|`String`
|`"mb"`

|`dialect.like.escape-char`
|The escape character for wildcard of LIKE condition
|`Character`
|`'\'` (backslash)

|`dialect.like.escape-clause-format`
|The format of escape clause for LIKE condition
(Can specify format that can be allowed by `String#format` method)
|`String`
|`"ESCAPE '%s'"`

|`dialect.like.additional-escape-target-chars`
|Additional escape target characters(custom wildcard characters) for LIKE condition
(Can specify multiple characters using comma(`","`) as separator character)
|`String`
|`""` (no specify)
|===

[source,properties]
.src/main/resources/mybatis-thymeleaf.properties
----
use-2way = true
customizer = com.example.MyTemplateEngineCustomizer
cache.enabled = true
cache.ttl = 3600000
file.character-encoding = UTF-8
file.base-dir = /templates/sqls
file.patterns = *sql, *.sql.template
dialect.prefix = mybatis
dialect.like.escape-char = ~
dialect.like.escape-clause-format = escape '%s'
dialect.like.additional-escape-target-chars = ％, ＿
----

[TIP]
====
These properties can be specified via builder class of `ThymeleafLanguageDriver` as follow:

[source,java]
----
configuration.getLanguageRegistry().register(ThymeleafLanguageDriver.newBuilder()
    .use2way(true)
    .customizer(CustomTemplateEngineCustomizer.class)
    .cacheEnabled(true)
    .cacheTtl(3600000)
    .fileCharacterEncoding(StandardCharsets.UTF_8)
    .fileBaseDir("/templates/sqls")
    .filePatterns("*.sql", "*.sql.template")
    .dialectPrefix("mybatis")
    .dialectLikeEscapeChar('~')
    .dialectLikeEscapeClauseFormat("escape '%s'")
    .dialectLikeAdditionalEscapeTargetChars('％' , '＿')
    .build());
----

If you specify the value both with properties file and builder option, the properties file value applied.
====


=== Bulk insert

This section describe about bulk insert for collection or array using SQL rather than JDBC feature.
If you want to insert a collection or array by bulk, you can be realized it using the `th:each` and `mb:p` attribute tags as follow:


[source,java]
.Domain objects
----
public class Person {
  private int id;
  private String firstName;
  private String lastName;
  private LocalDate dateOfBirth;
  private List<Mail> mails;
  // ...
}
public class Mail {
  private int id;
  private int personId;
  private String address;
  // ...
}
----

[source,java]
.Mapper methods
----
@Options(useGeneratedKeys = true, keyProperty = "id")
@Insert("/sqls/PersonMapper_insertByBulk.sql")
void insertByBulk(List<Person> persons);

@Insert("/sqls/PersonMapper_insertMailsByBulk.sql")
void insertMailsByBulk(List<Person> persons);
----

[source,sql]
.SQL template for top level collection/array
----
INSERT INTO persons
  (first_name, last_name, date_of_birth)
VALUES
/*[# th:each="person : ${list}"]*/ -- <1>
  (
    /*[# mb:p="person.firstName"]*/ 'Taro' /*[/]*/, -- <2>
    /*[# mb:p="person.lastName"]*/ 'Yamada' /*[/]*/,
    /*[# mb:p="person.dateOfBirth"]*/ '2000-03-28' /*[/]*/
  )/*[(${personStat.last} ? '' : ',')]*/
/*[/]*/
----

[source,sql]
.SQL template for nested property collection/array
----
INSERT INTO person_mails
  (person_id, address)
VALUES
/*[# th:each="person : ${list}"]*/ -- <1>
  /*[# th:each="mail : ${person.mails}"]*/ -- <3>
    (
      /*[# mb:p="person.id"]*/ 1 /*[/]*/,
      /*[# mb:p="mail.address"]*/ 'taro.yamada@mybatis.org' /*[/]*/ -- <4>
    )/*[(${personStat.last and mailStat.last} ? '' : ',')]*/
  /*[/]*/
/*[/]*/
----

<1> Fetch and store to local variable(e.g. `person`) an element object of top level collection/array using `th:each`
<2> Specify a property of element object fetched from top level collection/array as bind variable using `mb:p`
<3> Fetch and store to local variable(e.g. `mail`) and element object of nested property collection or array
<4> Specify a property of element object fetched from nested property collection/array as bind variable using `mb:p`

The `mb:p` register an element object that fetched from collection/array to the MyBatis’s bind variables.


=== Multiline String Literals

You can specify an SQL in annotation using "link:https://openjdk.java.net/jeps/326[Raw String Literals^]" feature that support by future JDK version.
Also,"Multiline String Literals" provided other JVM languages (such as Kotlin and Groovy) can be used.
There is a good compatibility with annotation driven mapper.

==== Java

* link:https://openjdk.java.net/jeps/326[Raw String Literals^] (Not released yet)

[source,java]
----
@Select(``
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
``)
Name findById(Integer id);
----

==== Kotlin

* link:https://kotlinlang.org/docs/reference/basic-types.html#string-literals[String Literals^]

[source,kotlin]
.Kotlin
----
@Select("""
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
""")
fun findById(id: Int): Name
----

==== Groovy

* link:http://docs.groovy-lang.org/latest/html/documentation/#_triple_single_quoted_string[Triple single quoted string^]

[source,groovy]
.Groovy
----
@Select('''
  SELECT * FROM names
    WHERE id = /*[# mb:p="id"]*/ 1 /*[/]*/
''')
Todo findById(int id);
----

